\documentclass[12pt, letterpaper]{article}
\usepackage{graphicx}
\graphicspath{ {Images/} }

\begin{document}
\noindent \textbf{\large Assignment 3 Heuristic Search }\newline
\noindent \textbf{By Brandon Young and Ruicheng Wu}

\bigskip

\noindent \textbf{A. Interface}

Here are two examples of the GUI. The first image shows the overall GUI. The buttons on the top-left are used to interact with the grid. The red "Show Path" button is used to upload a path file to show a green path on the grid. The yellow "File Output" is used to output a file representing the current grid. The blue "Upload" button is used to upload and show a grid from an existing file. Clicking on a cell on the grid shows its h, g and f values below the buttons and above the grid.

\medskip

\noindent \includegraphics[scale=0.35]{"a-map1-0"}

\medskip 

This second image shows a closer look to the grid representation. Red squares represent blocked cells, gray for hard-to-traverse cells and white for unblocked cells. A black circle within a square shows that the cell has a highway on it. Green P's show the path. The start (in blue) and goal (in purple) are either represented by S and G respectively or pie-shaped symbols.

\medskip

\includegraphics[scale=0.45]{"a-map1-4"}

\medskip

\pagebreak %----------------------------------------------------------------------

\noindent \textbf{B. UCS, A* and Weighted A* Implementations}

There are three examples shown below, running uniform-cost search (UCS), A* and weighted A* respectively on the same map.

1. Uniform-cost search:\newline
\medskip
\textbf{Path length:143, Node Expanded:11595,	Run Time: 0.528}\newline
\noindent \includegraphics[scale=0.4]{"b-map5-1-u"}\newline

2. A * search: \newline
\medskip
\textbf{Path length:136, Node Expanded:1466,	Run Time: 0.109}\newline
\noindent \includegraphics[scale=0.4]{"b-map5-1-a"}\newline

3. Weighted A * search search:\newline
\medskip
\textbf{Path length:93, Node Expanded:93,	Run Time: 0.047}\newline
\noindent \includegraphics[scale=0.4]{"b-map5-1-w-2"}\newline


\pagebreak %--------------------------------------------------------------------

\noindent \textbf{C. Optimizations}

To optimize the search algorithms, we used a Python dictionary as a heap, rather than a Python list (array), to implement the closed list more efficiently. Since we just needed to insert or check if a pair of coordinates existed inside the close list, a heap would speed up the check and may help the insertion. Overall, checking if a element exists takes O(n) for an array and O(1) for a heap.

For the heap, we initially used the sum of coordinate values to use as the key. However, this meant for every (x, y) there is a matching pair (y, x) with the same key. In addition, as the sums increased, there were a greater number of pairs that summed to the same value. As a result, we decided to distinguish (x, y) by multiplying x with a hash code value. With some testing, higher hash codes lowered the average size of a list for each key so we ended up using 91 as the hash code. 

We also optimized the way the heuristic was applied to the grid. At first we applied the heuristic over the entire graph before running the search algorithm. However, this wasted resources when only a portion of the overall grid was searched. Instead, we compute the heuristic during the search, to ensure only relevant cells in the grid have the heuristic applied to them.

\pagebreak %----------------------------------------------------------------

\noindent \textbf{D. Heuristics}

\noindent 1. Diagonal Distance Heuristic

The formula for cell $(x1,y1)$ and goal $(x2, y2)$ is:
$$h((x1, y1)) = dx + dy (\sqrt{2} - 2) * min(dx, dy)$$
where $dx = |x2 - x1|$ and $dy = |y2 - y1|$.

The best admissible/consistent heuristic we used was the diagonal distance heuristic. The diagonal distance heuristic is similar to the Manhattan distance heuristic, except it every cell in the grid is an unblocked cell, then computes the shortest path using diagonal, horizontal and vertical steps it takes to move from the start to the goal. 

Diagonal distance was preferred over Euclidean distance because the movements it allows is close to the movements allowed on the actual grid. Therefore, the heuristic value will come closer to the actual optimal distance than the value from Euclidean distance.

\bigskip
\noindent 2. Euclidean Distance

Euclidean distance is also a admissible/consistent heuristic as it works on a subproblem of the grid problem where any degree of movement is allowed.

The formula for cell $(x1, y1)$ and goal $(x2, y2)$ is:
$$h((x1,y1)) = \sqrt{(x2-x1)^2 + (y2-y1)^2}$$

\bigskip
\noindent 3. Manhattan Distance

This heuristic assumes every cell in the grid is an unblocked cell, then computes the shortest path using only horizontal and vertical steps.

The formula for cell $(x1, y1)$ and goal $(x2, y2)$ is:
$$h((x1, y1)) = dx + dy$$
where $dx = |x2 - x1|$ and $dy = |y2 - y1|$.

The heuristic is inadmissible for the grid problem because diagonal movements are allowed. As a result, Manhattan distance tends to overestimate the actual cost to the goal. Nevertheless, this metric can come in handy for sequential A* search because it overestimates.

\bigskip
\noindent 4. Euclidean Squared

The formula for cell $(x1, y1)$ and goal $(x2, y2)$ is:
$$h((x1,y1)) = (x2-x1)^2 + (y2-y1)^2$$

Similar to Euclidean distance, but outputting much higher values, so the heuristic is not admissible. However, because the square root is not used, some computation time is saved. In general, pretty bad heuristic because its h-value will tend to be much higher than the g-value.

\bigskip
\noindent 5. Sample Heuristic

The heuristic given in the assignment instructions. May not be admissible or consistent for the grid problem. 

The formula for cell $(x1, y1)$ and goal $(x2, y2)$ is:
$$h((x1,y1)) = \sqrt{2} * min(dx, dy) + max(dx, dy) - min(dx, dy)$$
where $dx = |x2 - x1|$ and $dy = |y2 - y1|$. 

\pagebreak %---------------------------------------------------------------

\noindent \textbf{E. UCS, A*, Weighted A* Statistics}

\noindent \includegraphics[scale=0.6]{"avg-nodeexpanded"}

\medskip

\noindent \includegraphics[scale=0.8]{"avg-pathlength"}

\medskip

\noindent \includegraphics[scale=0.8]{"avg-runtime"}

\medskip
\end{document}